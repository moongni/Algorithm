# 동적 계획법
## 메모이제이션 (memoization)
함수의 결과를 저장하는 저장소를 만들어 재활용하는 최적화 기법

메모이제이션을 사용한다면 부분 문제가 한 번씩만 계산된다고 보장할 수 있기 때문에 함수 호출 횟수가 감소한다.

## 메모이제이션 적용 가능 경우 - 참조적 투명성
함수의 입력 값이 반환값을 결정하는지의 여부로 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들을 참조적 투명 함수라고 한다.

메모이제이션은 참조적 투명 함수에만 적용가능하다. 만일 입력 값이 같은 경우에 외부 요소에 따라 반환 값이 다르다면 캐싱을 할 수 없다.

## 메모이제이션 구현 패턴
한 번 계산하는데 오랜 시간이 걸리는 참조적 투명 함수인 재귀함수가 있을 때,

- 기저 사례 처리 : 입력이 범위를 버섯난 경우 등을 처리
- 이미 계산을 한 적이 있는 경우 캐싱을 통해 처리
- 반환 값은 캐싱의 참조형이기 때문에 반환값을 변환시키면 캐싱의 값이 달라질 수 있음
- 캐싱 초기화 

## 메모이제이션 시간복잡도
존재하는 부분 문제 수 X 한 부분 문제를 풀 때 필요한 수행 횟수

이 식은 수행 시간의 상한을 간단히 계산할 수 있는 방법으로 정확하지 않다.

## 최적 부분 구조 (Optimal Substructure)
어떤 문제와 분할 방식에 성립하는 조건으로 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있을 경우 이 조건이 성립한다고 한다.

지금까지의 선택과 상관 없이 각 부분 문제를 최적으로 풀기만 하면 전체 문제의 최적해를 찾을 수 있다.

예시 서울에서 부산까지 최적의 경로

대전에서 부산까지 최적의 경로가 존재한다면 서울에서 대전까지 최적의 경로를 합치면 서울에서 부산까지 최적의 경로일 것임.

이 경우 최적 부분 구조임.

하지만 서울에서 부산까지 최적의 경로 중 비용이 3만원 이하인 경로라는 조건이 달리면

대전에서 부산까지 최적의 경로에 대한 비용에 따라 서울에서 대전까지 경로가 변화할 수 있음.

이 경우 최적 부분 구조가 아님

## 최적화 문제 동적 계획법 레시피
최적화 문제의 동적 계획법을 설계하기 위한 과정을 정리

1. 모든 답을 만들어 보고 그 중 최적해를 반환하는 완전탐색알고리즘 설계
2. 전체 답의 점수를 반환하는 것이 아닌 해당하는 점수만을 반환하도록 부분 문제 정의
3. 재귀 호출 입력 이전의 선택에 관련된 정보가 있으면 필요한 것이 아닌 이상 정리 최적 부분 구조가 성립될 시 완전 제거 가능, 가능한 중복되는 부분 문제를 많이 만듬 >> 최도한도의 메모이제이션 가능
4. 입력이 배열이거나 문자열인 경우 가능하면 변환을 통해 메모이제이션
5. 메모이제이션 적용

